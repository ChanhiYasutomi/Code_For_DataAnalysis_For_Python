1レコードに対してカラムを紐づける場合、max で集約してフラグを立てても良い



「startdatetime」が「0秒」で、「enddatetime」が「59秒」に設定される処理は、一般的には以下のような理由から行われることがあります：
時刻の整合性: データベースやファイルから時刻情報を取得する際、秒単位までの時刻情報を持っていない場合、デフォルトで秒を「0」に設定し、「enddatetime」が「59」に設定することで、時刻の整合性を保ちます。これにより、時刻情報が不足している場合でも、時刻の範囲を明確に設定できます。
時間範囲の設定: イベントやキャンペーンなどの時間範囲を設定する場合、終了時刻を秒単位で指定することが一般的です。秒が「59」に設定されることで、指定した時間範囲の終了時刻が含まれることが保証されます。たとえば、キャンペーンの終了時刻が「15:30:59」であれば、そのキャンペーンは15時30分59秒まで有効であると解釈されます。
時刻の比較やフィルタリング: プログラム内で時刻の比較やフィルタリングを行う場合、秒単位までの時刻情報が揃っていることが重要です。秒を「59」に設定することで、秒単位で時刻情報を扱う際に誤差が発生しないようにします。
したがって、特定のコンテキストや要件に応じて、秒を「0」または「59」に設定することが行われます。このような処理は、時刻情報の正確さと整合性を保つために役立ちます。



df_tmp = df.groupby(['cum'])['target'].agg(["count","sum"])
df_tmp["ratio"] = df_tmp["sum"] / df_tmp["count"]
df_tmp["check"] = np.where(df_tmp["ratio"] >= 0.90, 1, 0)

"""

例えば、cum=10 の場合、
0:   136
1:  5967
の割合になっていて、98% のユーザーは再購入する。
理想的には、この中から136人のユーザー(2%)を正確に当てたいのだが、人数はかなり少ない。
ある意味、2%のユーザーは異常値ということ。異常度みたいなものをうまく捉えられないか？？ ワンクラスSVM, クラスタリング距離…。

案1:
cum が 2,3 までは不均衡対策をし、cum 4 ~ 22 のデータはある程度 1 の件数を減らして学習データを作るか？
ゼロ側の件数を取得して、その件数の1.2倍をクラス1側からランダムサンプリングする関数を作ってみる。

cum が 23 あたりからリピート率が100%に張り付いている。
cum が 23 以上はノイズになりそうなので学習データから除外し、
推論するときは 全て 1として予測する。
target が 0 の人も 1 として予測されるが、ゼロの件数は非常に少ないのでビジネス的な損失インパクトは低い。

案2: One-Class SVM, ワンクラスSVM
https://twitter.com/kenken26679105/status/1678896738302832641?s=20
→cum 4 以上 のデータは普通にワンクラスSVMの方が予測精度は高いかも。
cum が 2,3 までは不均衡対策をしてLihgtGBMでやって、最後に合算させて評価する。

案3: 残差を標準化し、その絶対値を、外れ値のScoreとする
target - 分類確率(ロジスティック回帰で算出) = 残差 として、それを標準化し、外れ値をスコア化する。これを特徴量として追加してみる。
https://twitter.com/kenken26679105/status/1675409941501448192/photo/2
https://twitter.com/kenken26679105/status/1675435607051624448/photo/3

案4: 案3 の特徴量に、クラスタリング距離を追加
https://twitter.com/kenken26679105/status/1611682364077527041/photo/1
G-means と X-means の両方を試して、平均値をクラスター数にする。
あとは、クラスタリング距離を特徴量として追加する。

https://twitter.com/kenken26679105/status/1611682364077527041/photo/1

"""
